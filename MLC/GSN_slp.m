function [wn, un, zn, Awn, Tn, r] = GSN_slp( w0, u0, z0, A, b, rho, lambda, mu, c1)
% =========================================================================
% A gradient subspace Newton method for approximately solving subproblems 
% generated by iNALM
% =========================================================================
% Variables:
% (w0,u0,z0):    Initial point (w^{k,0},u^{k,0},z^{k,0}) = (w^k,u^k,z^k)
% (w,u,z):       Current iterate (w^{k,j}, u^{k,j}, z^{k,j})
% (w12,u12,z12): Intermediate iterate (w^{k,j+1/2}, u^{k,j+1/2}, z^{k,j+1/2})
% (wn,un,zn):    New point ( w^{k,j+1},u^{k,j+1},z^{k,j+1} )
% (wnn,unn,znn): New point ( w^{k,j+2},u^{k,j+2},z^{k,j+2} )
% T:             Current index set T_{k,j}; 
% Tn:            New index set  T_{k,j+1}; 
% =========================================================================
% Written by Penghe Zhang on 28/09/2022 based on the algorithm proposed in
%     Penghe Zhang, Naihua Xiu, Houduo Qi, 
%     iNALM: An inexact Newton Augmented Lagrangian Method for Zero-One 
%     Composite Optimization.
% Send your comments and suggestions to <<< phzhang971001@gmail.com >>>                                  
% =========================================================================
t0 = 1;
theta_t = 10;
tau1 = 1e-3;
c2 = 1e-2;
sigma = 1e-5;
jmax = 100;
acc = zeros(jmax,1);
Lya = zeros(jmax,3);
SC = zeros(jmax,2);
p = numel(w0);
n = numel(u0);
accmax = 0;


flag = 0;
flag_sp = issparse(A);

Fnorm2  = @(var)norm(var)^2;

Aw0 = A*w0;
w = w0;
Aw = Aw0;
r = Aw + b + z0/rho;
T = find(r >= 0 & r < sqrt(2*lambda/rho));
u12 = r;
u12(T) = 0;

t = t0;
for j = 1:jmax
    %w-step
    numT = numel(T);

    if numT && flag      %if flag = 1, T=Tn, then we needn't compute AT again
        rT = r(T);
        ArT = (rT'*AT)'; %A^\top * r
    elseif numT
        AT = A(T,:);
        rT = r(T);
        ArT = (rT'*AT)'; 
    else
        ArT = 0;
    end
    
    f = fun_slp( w,"fun");
    AL = ALag( f, u12, z0, Aw, b, rho, lambda );
    V = AL + mu*Fnorm2(w - w0)/2;

    %line search
%     t = t0;
    for jl = 1:20

        if jl == 1
            temw = mu*w0 + t*w - (fun_slp(w,"grad") + rho*ArT);
            temAw = A*temw;
            w12 = temw/(t + mu);
            Aw12 = temAw/(t+mu);
        else
            temw = temw + (1-1/theta_t)*t*w;
            temAw = temAw + ( 1-1/theta_t )*t*Aw;
            w12 = temw/(t+mu);
            Aw12 = temAw/(t+mu);
        end   
        
        f12 = fun_slp(w12,"fun");
        AL12 = ALag( f12, u12, z0, Aw12, b, rho, lambda );
        V12 = AL12 + mu*Fnorm2(w12 - w0)/2;

        if V - V12 >= tau1*Fnorm2(w12 - w)
            break;
        else
            t = t*theta_t;
        end
    end

    H_f12 = fun_slp(w12,"hessian");
    H_mu = H_f12 + mu;
    if numT
        
    %Newton step
        if p < numT
            rhs = z0 + rho*b;
            rhs = rhs(T);
            rhs = - fun_slp(w12,"grad") + H_f12.*w12 + mu*w0 - (rhs'*AT)';

            if p < 600 || (~flag_sp && p < 2000)
                Hg = rho*(AT'*AT);
                Hg(1:p+1:end) = H_mu' + Hg(1:p+1:end);
                wn = Hg\rhs;
            else
                Matvec = @(var)( H_mu.*var + rho*((AT*var)'*AT)' );
                wn = cgn(Matvec,rhs);
            end

        else
            z12 = z0 + rho*(Aw12 + b - u12);
            H_inv = 1./H_mu;
            tem = rho*AT.*H_inv';
            rhs = z12(T) - tem*(fun_slp(w12,"grad") + mu*(w12 - w0));
            if numT < 600 || (~flag_sp && numT < 2000)
                Hg = tem*AT';
                Hg(1:numT+1:end) = 1 + Hg(1:numT+1:end);
                znT = Hg\rhs;
            else
                Matvec = @(var)( var + tem*(var'*AT)' );
                znT = cgn(Matvec,rhs);
            end
            wn = - fun_slp(w12,"grad") + H_f12.*w12 + mu*w0 - (znT'*AT)';
            wn = H_inv.*wn;
        end
    else
        rhs = - fun_slp(w12,"grad") + H_f12.*w12 + mu*w0;
        wn = rhs./H_mu;
    end

    Awn = A*wn;
    rn = Awn + b + z0/rho;
    un = rn;
    un(T) = 0;
  
    fn = fun_slp(wn,"fun");
    ALn = ALag( fn, un, z0, Awn, b, rho, lambda );
    Vn = ALn + mu*Fnorm2(wn - w0)/2;
    
    %switch step
    if V12 - Vn < sigma*( Fnorm2( wn - w12 ) + Fnorm2( un - u12 ) ) && (j > 10 || p <= 50)
        wn = w12;
        un = u12;
        Awn = Aw12;
        rn = Awn + b + z0/rho;
        SC1 = norm( wn - w );
    else
        SC1 = Fnorm2( wn - w12 );
    end
    Lya(j,:) = [V,V12,Vn];    

    %u-step
    Tn = find(rn >= 0 & rn < sqrt(2*lambda/rho));
    flag = isequal(T,Tn);      
    unn = rn;
    unn(Tn) = 0;
    zn = rho*( rn - un );

    acc(j) = nnz(Awn < 0)/n;

    if acc(j) >= accmax
        accmax = acc(j);
        wmax = wn;
        itermax = j;
        umax = un;
        zmax = zn;
        Awmax = Awn;
        Tmax = Tn;
        rmax = rn;
    end

    %stopping criteria
    SC2 = norm( unn - un );
    dist = norm(wn - w0);
    SC(j,:) = [SC1,SC2];
    eps = 10*lambda/rho/j;
    SC3 = lambda/rho*(nnz(unn > 0) - nnz(un > 0)) - 0.5*Fnorm2(unn-un) - zn'*(unn - un);

    Cod1 = SC1 < c1*dist && SC2 < c2*dist^2 && SC3 < eps;
    Cod2 = p<=2000 && (acc(j) <= accmax - 1e-3 || j - itermax >= 4 || acc(j) >= 0.95);
    Cod3 = p<=2000 && (j >= 3 && (nnz(acc(j-1:j) - acc(j-2:j-1)) == 0));
    if Cod1 || Cod2 || Cod3
        if p <= 2000
            wn = wmax;
            un = umax;
            zn = zmax;
            Awn = Awmax;
            Tn = Tmax;
            r = rmax;
        end
        break;
    end

    if j == 10   
        w = w0;
        Aw = Aw0;
        r = Aw + b + z0/rho;
        T = find(r >= 0 & r < sqrt(2*lambda/rho));
        u12 = r;
        u12(T) = 0;
        flag = 0;
    else
        u12 = unn;
        w = wn;
        Aw = Awn;
        r = rn;
        T = Tn;
    end
    
end

end