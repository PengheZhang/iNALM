function [wn, un, zn, Awn, Tn, r] = GSN( w0, z0, A, b, rho, lambda, mu, c1, delta)
% =========================================================================
% A gradient subspace Newton method for approximately solving subproblems 
% generated by iNALM
% =========================================================================
% Variables:
% (w0,u0,z0):    Initial point (w^{k,0},u^{k,0},z^{k,0}) = (w^k,u^k,z^k)
% (w,u,z):       Current iterate (w^{k,j}, u^{k,j}, z^{k,j})
% (w12,u12,z12): Intermediate iterate (w^{k,j+1/2}, u^{k,j+1/2}, z^{k,j+1/2})
% (wn,un,zn):    New point ( w^{k,j+1},u^{k,j+1},z^{k,j+1} )
% (wnn,unn,znn): New point ( w^{k,j+2},u^{k,j+2},z^{k,j+2} )
% T:             Current index set T_{k,j}; 
% Tn:            New index set  T_{k,j+1}; 
% =========================================================================
% Written by Penghe Zhang on 28/09/2022 based on the algorithm proposed in
%     Penghe Zhang, Naihua Xiu, Houduo Qi, 
%     iNALM: An inexact Newton Augmented Lagrangian Method for Zero-One
%     Composite Optimization.
% Send your comments and suggestions to <<< phzhang971001@gmail.com >>>                                  
% =========================================================================

t0 = 1;
theta_t = 10;
tau1 = 1e-3;
c2 = 1e-1;
sigma = 1e-5;

p = numel(w0);
n = numel(z0);

Hsf = fun_wl2(w0,"hessian",delta) + mu; % \mu*I + \nabla^2 f(w)
H_inv = 1./Hsf;

flag = 0;
flag_sps = numel(A) <= 0.05*n*p;
Fnorm2  = @(var)norm(var)^2;
Aw0 = A*w0;
w = w0;
Aw = Aw0;
r = Aw + b + z0/rho;
T = find(r >= 0 & r < sqrt(2*lambda/rho));
u12 = r;
u12(T) = 0;
jmax = 100;


t = t0;
for j = 1:jmax
      
    %w-step
    numT = numel(T);

    if numT && flag      %if flag = 1, T=Tn, then we needn't compute AT again
        rT = r(T);
        ArT = (rT'*AT)'; %A^\top * r
    elseif numT
        AT = A(T,:);
        rT = r(T);
        ArT = (rT'*AT)'; 
    else
        ArT = 0;
    end

    f = fun_wl2( w,"fun",delta );
    AL = ALag( f, u12, z0, Aw, b, rho, lambda );
    V = AL + mu*Fnorm2(w - w0)/2;

    %line search
    for jl = 1:20
        if numT
            if jl == 1
                temw = mu*w0 + t*w - (fun_wl2(w,"grad",delta) + rho*ArT);
                temAw = A*temw;
                w12 = temw/(t + mu);
                Aw12 = temAw/(t+mu);
            else
                temw = temw + (1-1/theta_t)*t*w;
                temAw = temAw + ( 1-1/theta_t )*t*Aw;
                w12 = temw/(t+mu);
                Aw12 = temAw/(t+mu);
            end

        else                                              % if |T| = 0, the computational cost of Awn could be reduced.
            w12 = mu*w0 + t*w - fun_wl2(w,"grad",delta);
            w12 = w12/(t + mu);
            Ap = A(:,p);
            Aw12 = mu*Aw0 + (t - 1)*Aw + (1 - delta)*w(p)*Ap;   
            Aw12 = Aw12/(t+mu);
        end
        
        f12 = fun_wl2(w12,"fun",delta);
        AL12 = ALag( f12, u12, z0, Aw12, b, rho, lambda );
        V12 = AL12 + mu*Fnorm2(w12 - w0)/2;

        if V - V12 >= tau1*Fnorm2(w12 - w)
            break;
        else
            t = t*theta_t;
        end
    end

    if numT
    
        %Newton step
        if p < numT
            rhs = z0 + rho*b;
            rhs = rhs(T);
            rhs = mu*w0 - (rhs'*AT)';
            if p < 600 || (~flag_sps && p < 2000)
                Hg = rho*(AT'*AT);
                Hg(1:p+1:end) = Hsf' + Hg(1:p+1:end);
                wn = Hg\rhs;
            else
                Matvec = @(var)( Hsf.*var + rho*((AT*var)'*AT)' );
                wn = cgn(Matvec,rhs);
            end

        else
            z12 = z0 + rho*(Aw12 + b - u12);
            tem = rho*AT.*H_inv';
            rhs = z12(T) - tem*(fun_wl2(w12,"grad",delta) + mu*(w12 - w0));
            if numT < 600 || (~flag_sps && numT < 2000)
                Hg = tem*AT';
                Hg(1:numT+1:end) = 1 + Hg(1:numT+1:end);
                znT = Hg\rhs;
            else
                Matvec = @(var)( var + tem*(var'*AT)' );
                znT = cgn(Matvec,rhs);
            end
            wn = mu*w0 - (znT'*AT)';
            wn = H_inv.*wn;
        end
    else
        wn = mu*H_inv.*w0;
    end

    Awn = A*wn;
    rn = Awn + b + z0/rho;
    un = rn;
    un(T) = 0;
  
    fn = fun_wl2(wn,"fun",delta);
    ALn = ALag( fn, un, z0, Awn, b, rho, lambda );
    Vn = ALn + mu*Fnorm2(wn - w0)/2;
    
    %switch step 
    if V12 - Vn < sigma*( Fnorm2( wn - w12 ) + Fnorm2( un - u12 ) ) && (j > 10 || p <= 50)
        wn = w12;
        un = u12;
        Awn = Aw12;
        rn = Awn + b + z0/rho;

        SC1 = norm( wn - w );
    else
        SC1 = Fnorm2( wn - w12 );
    end

    %u-step
    Tn = find(rn >= 0 & rn < sqrt(2*lambda/rho));
    flag = isequal(T,Tn);      
    unn = rn;
    unn(Tn) = 0;

    %stopping criteria
    SC2 = norm( unn - un );
    zn = rho*(rn - un);
    SC3 = lambda*(nnz(un > 0) - nnz(unn > 0)) - 0.5/rho*Fnorm2(unn-un) - zn'*(unn - un);
    dist = norm(wn - w0);
    eps = 10*lambda/j;

    if SC1 <= c1*dist && SC2 <= c2*dist^2 && SC3 <= eps
        break;
    end

    u12 = unn;
    w = wn;
    Aw = Awn;
    r = rn;
    T = Tn;
end
end